# 共模攻击
from Crypto.Util.number import *
import gmpy2
n = 158052722013789461456896900244510199169216575693048895162538548356466884311543740968048825149608833390255268602486435690724338965409521812963337715301197225841194835534751041470231293288252951274190599189716955573428884560130364021535005115652592074445852835422027406556727605302404510264249211145063332337043
e1 = 665213
e2 = 368273
c1 = 16698617641888248664694980135332125531792692516788088682722832061393117609508765284473236240256421599515450690670639565968165473479697383505401285976148490839526672808730165847471005704945978274496508928460578173068717106075169723401049489389383596761956301440156581021583368058047939083755488885694261340425
c2 = 59192887933967939708054321952273893559113509451228797382728687616356609407020086787061368452871936378934964292805289941535766263083244529814852043063188312786173717046316177403357053871483983775362121186037776932260378728059531236711960979620603784044468207000654149190295060179235411429700710154759043236436
s0, s1, s2 = gmpy2.gcdext(e1, e2)
if s1 < 0:
    s1 = -s1
    c1 = gmpy2.invert(c1, n)
elif s2 < 0:
    s2 = -s2
    c2 = gmpy2.invert(c2, n)
m = gmpy2.powmod(c1, s1, n)*gmpy2.powmod(c2, s2, n) % n
print('[-]m is:', m)
print(long_to_bytes(m))

#p,q做加密指数（sage）
# from Crypto.Util.number import *
# c1= 17893542812755845772427795161304049467610774531005620109503081344099161906017295486868699578946474114607624347167976713200068059018517606363517478396368430072890681401898145302336139240273132723451063402106360810413024642916851746118524166947301681245568333254648265529408446609050354235727237078987509705857
# c2= 95580409405085606847879727622943874726633827220524165744517624606566789614499137069562997931972825651309707390763700301965277040876322904891716953565845966918293178547100704981251056401939781365264616997055296773593435626490578886752446381493929807909671245959154990639046333135728431707979143972145708806954
# n= 140457323583824160338989317689698102738341061967768153879646505422358544720607476140977064053629005764551339082120337223672330979298373653766782620973454095507484118565884885623328751648660379894592063436924903894986994746394508539721459355200184089470977772075720319482839923856979166319700474349042326898971
#
# PR.<m> = PolynomialRing(Zmod(n))
# f = m^2-(c1+c2)*m+c1*c2
# x0 = f.small_roots(X=2^400)
# print(x0)
# [1920535408007397834236393374892057067669865609963495845501]
#
# import libnum
# print(libnum.n2s(1920535408007397834236393374892057067669865609963495845501))

#给e1*e2
# n = 16282992590526808657350657123769110323293742472515808696156540766049532922340638986423163288656942484229334024198335416611687418341772216996129634991032127943095069143600315325916614910606100091970611448259491799589221889445348698100959509165262891180065554743420149168801638644589921791426690475846945077068114953844817073866258377206796158690941199907230130273657375727245023893672164113928189304228859412794067127721813637080447782673535996272223836127807775157150041664783263093604946744032762535394974814371771505843653571711445892969781888188805943142126747365056482511805191315474848971218180999336497135314654469910566730389765499603897685968204361422568601724914800686608628299192714352963744010136960423806304763245890692476493455775025753944860040020178234660999290356849442926396627701588938894161779071628447041006556793933320976506046066961014953196791133933438500843139378274786265308568167479880984705152809744111382599071097574636570516674122980589207824718402382459624138317432883921371298272851693734695823787102433937406420318428888224246291987404818042038201886113203158444083427668636941
# c1 = 15508846802476602732219982269293312372397631462289816533805702700260237855119470146237752798828431803179124957728439730580289236458563016332461725094295883030444173189424666004498359269921250956676320570006883951982237098373954348825003467019876101438948387668628518937831820206221522881150831840296199498447304138839838135264071071817072965792514115711621435317078108239744829134467948386247696344881838815422262901903767893118533887779588425725845820071451782420200868341564360095012698956683395031351656817392008005928265838760875070634021907630535014959579709368637536268853337028760833769278841040734409299575870823873616769863828516877971432999417800417684146077045836940988096634144368727546539602310924702126212020003620219218637652874119299016382481718659448722433296761241365473608283436835986184098161365747699791248301452334044327014782249692551362625130537300221641910570569803981153117200694806974917501061411963827755822672178568783269357196133308719688843211664095412087717861154226475203597889635926903753481174280305996204091501578865951177135086807765873529089048911740160698421289371229606
# c2 = 7038544062804420883340530319534054090343999593726615071597649914714397773106261660516938820194721330117082799104642674913839235601210294807255855747823709326405317366422536981850436536877639492293904186333547681934006229055311359852552059601531864585759120757265084674695094298158389804437120173997679271166467086009884419942249925895393890707373985126949313101489352481737754459985522998334847972008827503987883850638250024631354158979424169551575287515128697843093987592614974905262077415255065744686115142126350167970451060399517705823298929164793769442986603707135790651560436497661713972277808036463771768932747376668116480068277125579165831615220097562066809632099809702980365194257899499384219864311379004681733844738981954144617140038448109869114888325128710654235506628539192955240723379334422880368605005772426413018696218105733457019400100498450734710865067764542737004071080719589912326985050985424145053072697267879019954400205613591419766583673115931337146967400159040252514654983240188915104134405655336152730443436887872604467679522955837013574944135975481174502094839012368918547420588186051
# e1e2 = 59653
#
# import libnum
# import gmpy2
#
#
# def rsa_gong_N_def(e1, e2, c1, c2, n):  # 共模攻击函数
#     e1, e2, c1, c2, n = int(e1), int(e2), int(c1), int(c2), int(n)
#     print("e1,e2:", e1, e2)
#     s = gmpy2.gcdext(e1, e2)
#     print("mpz:", s)
#     s1 = s[1]
#     s2 = s[2]
#     if s1 < 0:
#         s1 = - s1
#         c1 = gmpy2.invert(c1, n)
#     elif s2 < 0:
#         s2 = - s2
#         c2 = gmpy2.invert(c2, n)
#     m = (pow(c1, s1, n) * pow(c2, s2, n)) % n
#     return int(m)
#
#
# def de(c, e, n):  # 因为此时的m不是真正的m，而是m^k，所以对m^k进行爆破
#     k = 0
#     while k < 1000:  # 指定k小于1000
#         mk = c + n * k
#         flag, true1 = gmpy2.iroot(mk, e)  # 返回的第一个数值为开方数，第二个数值为布尔型，可整除为true，可自行测试
#         if True == true1:
#             # print(libnum.n2s(int(flag)))
#             return flag
#         k += 1
#
#
# for e1 in range(2, e1e2):
#     if e1e2 % e1 == 0:  # 爆破可整除的e
#         e2 = e1e2 // e1
#         c = rsa_gong_N_def(e1, e2, c1, c2, n)
#         e = gmpy2.gcd(e1, e2)
#         m1 = de(c, e, n)
#         if m1:  # 指定输出m1
#             print(libnum.n2s(int(m1)))

